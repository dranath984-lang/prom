source("instalar_paquetes.R")  # Ajusta la ruta si est√° en una subcarpeta

instalar_y_cargar(
  paquetes_cran = c("fs", "here", "tidyverse", "data.table", "pheatmap", "writexl", "readxl", "skimr", "ggvenn", "factoextra", "stats","corrplot"),
  paquetes_bioc = c()
)

getwd()
dir_create("datos")        # Para archivos TSV
dir_create("scripts")      # Para scripts .R
dir_create("salidas")      # Para resultados
dir_create("salidas_data") # Para datos procesados    


# Nombres de archivo (sin extensi√≥n)
archivos <- c(
  "DE_EV",
  "DE_PHR-L7-RNAi",
  "DE_PHR-L7-Ox",
  "DE_PHR-L7-RNAi-LPivsEVLPi",
  "DE_PHR-L7Ox-LPivsEVLPi",
  "DE_PHR-L7RNAi_OPivsEV_OPi",
  "DE_PHR-L7Ox_OPivsEV_OPi"
)

# Leer todos los archivos y guardarlos en una lista
datos_list <- lapply(archivos, function(nombre) {
  read_excel(paste0("datos/", nombre, ".xlsx")) 
})


# Crear nombres de objetos m√°s cortos y seguros
nombres_limpios <- c(
  "ev",
  "rna",
  "ox",
  "rna_lp",
  "ox_lp",
  "rna_op",
  "ox_op"
)

# Asignar nombres a la lista
names(datos_list) <- nombres_limpios

###################

datos_list$ev       # DE_EV.xlsx
datos_list$rna      # DE_PHR-L7-RNAi.xlsx
datos_list$ox
datos_list$rna_lp 
datos_list$ox_lp    # DE_PHR-L7Ox-LPivsEVLPi.xlsx
datos_list$rna_op
datos_list$ox_op  
  
  

for (i in seq_along(nombres_limpios)) {
  assign(paste0("dat_", nombres_limpios[i]), datos_list[[i]])
}


data.frame(objeto = paste0("dat_", nombres_limpios), archivo = archivos)


#####################################

# Vector con nombres de tus objetos
objetos <- c("dat_ev", "dat_rna", "dat_ox", "dat_rna_lp", "dat_ox_lp", "dat_rna_op", "dat_ox_op")

# Recorrer cada objeto y mostrar informaci√≥n clave
for (obj in objetos) {
  cat("\nüîç Explorando:", obj, "\n")
  
  # Obtener el objeto
  tabla <- get(obj)
  
  # Mostrar dimensiones
  cat("üìê Dimensiones:", dim(tabla)[1], "filas x", dim(tabla)[2], "columnas\n")
  
  # Mostrar nombres de columnas
  cat("üß¨ Columnas:", paste(names(tabla), collapse = ", "), "\n")
  
  # Mostrar tipos de datos
  cat("üî§ Estructura:\n")
  str(tabla)
  
  # Mostrar primeras filas
  cat("üëÄ Primeras filas:\n")
  print(head(tabla))
  
  # Mostrar resumen estad√≠stico
  cat("üìä Resumen:\n")
  print(summary(tabla))
  
  # Mostrar resumen extendido si skimr est√° disponible
  if ("skimr" %in% rownames(installed.packages())) {
    cat("üìã Resumen extendido con skimr:\n")
    print(skimr::skim(tabla))
  }
  
  # Abrir en pesta√±a si est√°s en RStudio
  if (interactive()) {
    View(tabla)
  }
}


#############################################
# Definir funci√≥n para limpiar una tabla
clean_table <- function(tabla, origen) {
  # Paso 1: Renombrar columnas clave basado en posiciones observadas (col1 = GeneID, col8 = log2FC, col9 = padj)
  # Asumiendo estructura: col1 t√≠tulo/GeneID, col2-7 r√©plicas, col8 log2FC, col9 padj (ajusta si var√≠a)
  nombres <- names(tabla)
  tabla <- tabla %>%
    rename(
      GeneID = 1,          # Primera columna: t√≠tulo largo, pero fila 2+ son IDs
      log2FC = 8,          # Columna de log2FoldChange
      padj = 9             # Columna de padj
    ) %>%
    # Paso 2: Convertir a num√©rico (est√°n como chr)
    mutate(
      log2FC = as.numeric(log2FC),
      padj = as.numeric(padj)
    ) %>%
    # Paso 3: Drop r√©plicas y extras (mantener solo clave)
    select(GeneID, log2FC, padj) %>%
    # Paso 4: Filtrar filas inv√°lidas (e.g., si primera fila es header texto, o NA)
    filter(!is.na(GeneID) & str_detect(GeneID, "^Phvul\\."), na.rm = TRUE) %>%  # Solo IDs v√°lidos (empiezan con Phvul.)
    # Paso 5: Agregar origen
    mutate(tabla_origen = origen)
  
  return(tabla)
}

# Lista de objetos originales y sus or√≠genes (c√≥digos cortos para simplicidad)
tablas <- list(
  dat_ev = "ev",          # Empty Vector OPi vs LPi
  dat_rna = "rna",        # RNAi OPi vs LPi
  dat_ox = "ox",          # OX OPi vs LPi
  dat_rna_lp = "rna_lp",  # RNAi LPi vs EV LPi
  dat_ox_lp = "ox_lp",    # OX LPi vs EV LPi
  dat_rna_op = "rna_op",  # RNAi OPi vs EV OPi
  dat_ox_op = "ox_op"     # OX OPi vs EV OPi
)

# Aplicar la funci√≥n a cada tabla y guardar en lista
tablas_limpias <- map2(tablas, names(tablas), ~ clean_table(get(.y), .x))

# Nombrar la lista para f√°cil acceso (e.g., tablas_limpias$dat_ev)
names(tablas_limpias) <- names(tablas)

# Verificaci√≥n r√°pida: Dimensiones y head de una (e.g., dat_ev limpia)
dim(tablas_limpias$dat_ev)
head(tablas_limpias$dat_ev)

# Guardar la lista completa como RDS en salidas_data (para reuse en pr√≥ximos scripts)
saveRDS(tablas_limpias, here("salidas_data", "tablas_limpias.rds"))

# Opcional: Exportar cada limpia como CSV individual para chequeo manual
walk2(tablas_limpias, names(tablas_limpias), ~ write_csv(.x, here("salidas_data", paste0(.y, "_clean.csv"))))

###########################################################
# scripts/03_convert_csv_to_xlsx.R
# Objetivo: Convertir CSVs limpios a XLSX para legibilidad externa.

# Path a CSVs
###csv_dir <- here("salidas_data")

# Listar CSVs limpios
###csv_files <- dir_ls(csv_dir, regexp = "_clean\\.csv$")

# Convertir cada CSV a XLSX
###for (csv_path in csv_files) {
  # Cargar CSV
###  tabla <- read_csv(csv_path, show_col_types = FALSE)
  
  # Generar nombre XLSX (e.g., dat_ev_clean.xlsx)
###  xlsx_name <- str_replace(basename(csv_path), "\\.csv$", ".xlsx")
###  xlsx_path <- here("salidas_data", xlsx_name)
  
  # Escribir a XLSX
###  write_xlsx(tabla, xlsx_path)
  
###  cat("Convertido:", csv_path, "a", xlsx_path, "\n")
###}

##############################################################

# scripts/02_explore_clean_csvs.R
# Objetivo: Explorar caracter√≠sticas de los CSVs limpios en salidas_data (similar a loop original).

# Definir path a carpeta de CSVs
csv_dir <- here("salidas_data")

# Listar autom√°ticamente los CSVs que terminan en "_clean.csv" (ignora otros como .rds)
csv_files <- fs::dir_ls(csv_dir, regexp = "_clean\\.csv$")  # Usa fs para listar

# Extraer nombres base (e.g., "dat_ev" de "dat_ev_clean.csv")
objetos <- basename(csv_files) %>% str_remove("_clean\\.csv$")

# Recorrer cada CSV y mostrar informaci√≥n clave
for (i in seq_along(csv_files)) {
  obj <- objetos[i]
  file_path <- csv_files[i]
  
  cat("\nüîç Explorando CSV:", obj, "(de", file_path, ")\n")
  
  # Cargar el CSV
  tabla <- read_csv(file_path, show_col_types = FALSE)  # Silencia mensajes
  
  # Mostrar dimensiones
  cat("üìê Dimensiones:", nrow(tabla), "filas x", ncol(tabla), "columnas\n")
  
  # Mostrar nombres de columnas
  cat("üß¨ Columnas:", paste(names(tabla), collapse = ", "), "\n")
  
  # Mostrar tipos de datos
  cat("üî§ Estructura:\n")
  str(tabla)
  
  # Mostrar primeras filas
  cat("üëÄ Primeras filas:\n")
  print(head(tabla))
  
  # Mostrar resumen estad√≠stico
  cat("üìä Resumen:\n")
  print(summary(tabla))
  
  # Mostrar resumen extendido si skimr est√° disponible
  if ("skimr" %in% rownames(installed.packages())) {
    cat("üìã Resumen extendido con skimr:\n")
    print(skimr::skim(tabla))
  }
  
  # Abrir en pesta√±a si est√°s en RStudio
  if (interactive()) {
    View(tabla)
  }
}



###########################################################################
# Alternativa usando map2, que es m√°s expl√≠cito
tablas_renombradas <- map2(
  tablas_limpias,          # Argumento 1: la lista de tablas
  names(tablas_limpias),   # Argumento 2: el vector de nombres
  
  # La funci√≥n es la misma, pero ahora .x es un elemento del primer argumento
  # y .y es un elemento del segundo argumento
  ~ .x %>%
    rename_with(~ paste0(., "_", .y), c("log2FC", "padj")) %>%
    select(GeneID, starts_with("log2FC_"), starts_with("padj_"))
)




















#################################################################################
# scripts/03_merge_unificado.R
# Objetivo: Merge las 7 tablas limpias en un dataframe unificado (wide-format por GeneID).

# Cargar la lista de tablas limpias desde RDS (eficiente)
tablas_limpias <- readRDS(here("salidas_data", "tablas_limpias.rds"))
print(names(tablas_limpias))

# Muestra los nombres de las columnas de la primera tabla
print(names(tablas_limpias$dat_ev))
print(names(tablas_limpias$dat_rna))
print(names(tablas_limpias$dat_ox))
print(names(tablas_limpias$dat_rna_lp))
print(names(tablas_limpias$dat_ox_lp))
print(names(tablas_limpias$dat_rna_op))
print(names(tablas_limpias$dat_ox_op))

# Tambi√©n puedes ver las primeras filas para tener m√°s contexto
print(head(tablas_limpias$dat_ev))
print(head(tablas_limpias$dat_rna))
print(head(tablas_limpias$dat_ox))
print(head(tablas_limpias$dat_rna_lp))
print(head(tablas_limpias$dat_ox_lp))
print(head(tablas_limpias$dat_rna_op))
print(head(tablas_limpias$dat_ox_op))

# Paso a: Renombrar columnas para evitar conflictos en merge (agrega sufijo por origen)
# e.g., log2FC -> log2FC_ev, padj -> padj_ev (directo, sin rename previo)
tablas_renombradas <- imap(tablas_limpias, ~ .x %>%
                             dplyr::rename_with(~ paste0(., "_", .y), c("log2FC", "padj")) %>%  # Sufijo en columnas existentes
                             dplyr::select(GeneID, starts_with("log2FC_"), starts_with("padj_"))  # Drop tabla_origen si no necesitas
)

###########################################################################################################################
# Paso a: Renombrar columnas (versi√≥n con bucle for a prueba de errores)

# 1. Crear una lista vac√≠a para guardar los resultados
tablas_renombradas <- list()

# 2. Iterar sobre los NOMBRES de la lista original
for (nombre_tabla in names(tablas_limpias)) {
  
  cat("Procesando tabla:", nombre_tabla, "\n") # Mensaje para ver el progreso
  
  # 3. Obtener la tabla actual
  tabla_actual <- tablas_limpias[[nombre_tabla]]
  
  # 4. Renombrar y seleccionar columnas en esta tabla
  tabla_procesada <- tabla_actual %>%
    rename_with(~ paste0(., "_", nombre_tabla), c("log2FC", "padj")) %>%
    select(GeneID, starts_with("log2FC_"), starts_with("padj_"))
  
  # 5. Guardar la tabla procesada en la nueva lista
  tablas_renombradas[[nombre_tabla]] <- tabla_procesada
}

# El resto de tu script contin√∫a exactamente igual...
df_unificado <- reduce(tablas_renombradas, full_join, by = "GeneID")










# Paso b: Merge secuencial con reduce y full_join por GeneID
df_unificado <- reduce(tablas_renombradas, full_join, by = "GeneID")

# Paso c: Manejar duplicados GeneID (si hay, aunque raro)
# Chequea y resume (e.g., media de log2FC si duplicado)
duplicados <- df_unificado %>%
  group_by(GeneID) %>%
  filter(n() > 1)

if (nrow(duplicados) > 0) {
  cat("‚ö†Ô∏è Duplicados encontrados:", nrow(duplicados), "- Resumiendo con media.\n")
  df_unificado <- df_unificado %>%
    group_by(GeneID) %>%
    summarise(across(everything(), ~ mean(.x, na.rm = TRUE)))  # Media para num, o ajusta
} else {
  cat("‚úÖ No duplicados en GeneID.\n")
}

# Verificaci√≥n post-merge
cat("üìê Dimensiones unificado:", nrow(df_unificado), "filas x", ncol(df_unificado), "columnas\n")
cat("üß¨ Columnas:", paste(names(df_unificado), collapse = ", "), "\n")
cat("üëÄ Primeras filas:\n")
print(head(df_unificado))
cat("üìä Resumen:\n")
print(summary(df_unificado))
# Opcional: skim(df_unificado) si skimr cargado
if ("skimr" %in% rownames(installed.packages())) {
  print(skimr::skim(df_unificado))
}

# Abrir en View para inspecci√≥n
if (interactive()) {
  View(df_unificado)
}

# Paso d: Guardar unificado
saveRDS(df_unificado, here("salidas_data", "df_unificado.rds"))
write_csv(df_unificado, here("salidas_data", "df_unificado.csv"))  # Opcional CSV para backup
cat("üíæ Guardado en salidas_data/df_unificado.rds y .csv\n")

##########################################################################################

sessionInfo()

##########################################################################################
#Dise√±o del Script para Crear la Matriz log2FC por GeneID/Tabla

# scripts/04_create_matrices.R
# Objetivo: Crear matriz log2FC (y opcional padj) por GeneID/tabla a partir de df_unificado.

# Cargar paquetes
library(tidyverse)  # Para select, mutate, etc.
library(here)       # Para paths

# Cargar df_unificado desde RDS
df_unificado <- readRDS(here("salidas_data", "df_unificado.rds"))

# Paso 1: Crear matriz log2FC
# Selecciona GeneID + todas columnas que empiezan con "log2FC_"
matriz_log2FC <- df_unificado %>%
  select(GeneID, starts_with("log2FC_")) %>%  # Matriz: rows=GeneID, cols=tablas
  # Opcional: Manejar NA (e.g., imputar 0 para no-DEGs, pero cuidado‚Äîpuede bias; deja NA para ahora)
  # mutate(across(starts_with("log2FC_"), ~ replace_na(., 0))) %>%
  arrange(GeneID)  # Ordena por GeneID para consistencia

# Verificaci√≥n
cat("üìê Dimensiones matriz_log2FC:", nrow(matriz_log2FC), "filas x", ncol(matriz_log2FC), "columnas\n")
cat("üß¨ Columnas:", paste(names(matriz_log2FC), collapse = ", "), "\n")
cat("üëÄ Primeras filas:\n")
print(head(matriz_log2FC))
cat("üìä Resumen:\n")
print(summary(matriz_log2FC))
# Opcional skim
if ("skimr" %in% rownames(installed.packages())) {
  print(skimr::skim(matriz_log2FC))
}

# Abrir en View
if (interactive()) {
  View(matriz_log2FC)
}

# Opcional: Crear matriz padj similar (para filtrar overlaps por significancia)
matriz_padj <- df_unificado %>%
  select(GeneID, starts_with("padj_")) %>%
  # mutate(across(starts_with("padj_"), ~ replace_na(., 1))) %>%  # NA=1 (no sig) si quieres
  arrange(GeneID)

# Verificaci√≥n similar para padj (repite si usas)
cat("üìê Dimensiones matriz_padj:", nrow(matriz_padj), "filas x", ncol(matriz_padj), "columnas\n")
# ... (agrega head/summary/skim similar)

# Guardar matrices
saveRDS(matriz_log2FC, here("salidas_data", "matriz_log2FC.rds"))
write_csv(matriz_log2FC, here("salidas_data", "matriz_log2FC.csv"))
saveRDS(matriz_padj, here("salidas_data", "matriz_padj.rds"))  # Opcional
write_csv(matriz_padj, here("salidas_data", "matriz_padj.csv"))  # Opcional
cat("üíæ Matrices guardadas en salidas_data.\n")

##################################################################################
#####################################################################

# scripts/05_venn_overlaps.R
# Objetivo: Filtrar genes up, crear listas por grupo (LPi vs OPi), calcular overlaps/Venn.

# Cargar matrices desde RDS
matriz_log2FC <- readRDS(here("salidas_data", "matriz_log2FC.rds"))
matriz_padj <- readRDS(here("salidas_data", "matriz_padj.rds"))

# Definir thresholds para "up" genes (ajusta seg√∫n necesidad, e.g., log2FC >1 = 2x up, padj <0.05)
fc_threshold <- 0.5    # log2FC >1
padj_threshold <- 0.05

# Definir grupos de tablas (basado en LPi vs OPi focus)
grupo_LPi <- c("log2FC_dat_ev", "log2FC_dat_rna_lp", "log2FC_dat_ox_lp")  # LPi-related
grupo_OPi <- c("log2FC_dat_rna_op", "log2FC_dat_ox_op")                   # OPi-related
# Opcional: Agrega m√°s grupos, e.g., RNAi: "log2FC_dat_rna", "log2FC_dat_rna_lp", "log2FC_dat_rna_op"

# Funci√≥n para filtrar genes up en un grupo de columnas
get_up_genes <- function(mat_fc, mat_padj, grupo_cols) {
  mat_fc %>%
    filter(if_any(all_of(grupo_cols), ~ . > fc_threshold) &  # Up en TODAS columnas del grupo (stricter; usa if_any para ANY)
             if_any(matches(str_replace(grupo_cols, "log2FC", "padj")), ~ . < padj_threshold)) %>%  # Sig en padj correspondientes
    pull(GeneID) %>%  # Extrae lista de GeneID
    unique()          # Evita dups
}

# Crear listas de genes up por grupo
genes_up_LPi <- get_up_genes(matriz_log2FC, matriz_padj, grupo_LPi)
genes_up_OPi <- get_up_genes(matriz_log2FC, matriz_padj, grupo_OPi)

# Verificaci√≥n: Conteos iniciales
cat("Genes up en LPi grupo:", length(genes_up_LPi), "\n")
cat("Genes up en OPi grupo:", length(genes_up_OPi), "\n")

# Paso para overlaps/counts (simple intersecci√≥n)
overlap_LPi_OPi <- intersect(genes_up_LPi, genes_up_OPi)  # Compartidos
unique_LPi <- setdiff(genes_up_LPi, genes_up_OPi)         # √önicos LPi
unique_OPi <- setdiff(genes_up_OPi, genes_up_LPi)         # √önicos OPi

cat("Overlap (compartidos):", length(overlap_LPi_OPi), "\n")
cat("√önicos LPi:", length(unique_LPi), "\n")
cat("√önicos OPi:", length(unique_OPi), "\n")

# Crear matriz binaria de presencia (1=up en tabla, 0=no) para an√°lisis avanzado
# Usa matriz_log2FC como base, binariza basado en thresholds
matriz_binaria <- matriz_log2FC %>%
  mutate(across(starts_with("log2FC_"), 
                ~ ifelse(. > fc_threshold & 
                           matriz_padj[[str_replace(cur_column(), "log2FC", "padj")]] < padj_threshold, 1, 0)))

# Verificaci√≥n matriz binaria
cat("üìê Dimensiones matriz_binaria:", nrow(matriz_binaria), "filas x", ncol(matriz_binaria), "columnas\n")
print(head(matriz_binaria))
print(summary(matriz_binaria))  # Deber√≠a mostrar 0/1/NA

# Venn plot simple (para 2 grupos; extiende a m√°s con list)
venn_list <- list(LPi = genes_up_LPi, OPi = genes_up_OPi)
ggvenn(venn_list, fill_color = c("blue", "green"), show_percentage = TRUE) +
  ggtitle("Venn: Up genes LPi vs OPi")
ggsave(here("salidas", "venn_LPi_vs_OPi.png"))  # Guarda plot

# Guardar outputs
saveRDS(venn_list, here("salidas_data", "venn_lists.rds"))  # Listas para reuse
write_csv(matriz_binaria, here("salidas_data", "matriz_binaria.csv"))  # Matriz para an√°lisis
cat("üíæ Outputs guardados en salidas_data y salidas.\n")

###############################################################################

#Extraer listas de GeneID para promotores
write_csv(tibble(GeneID = unique_LPi), here("salidas_data", "candidatos_LPi_unicos_Venn.csv"))
write_csv(tibble(GeneID = overlap_LPi_OPi), here("salidas_data", "candidatos_compartidos_Venn.csv"))
write_csv(tibble(GeneID = unique_OPi), here("salidas_data", "candidatos_OPi_unicos_Venn.csv"))

################################################################################
# scripts/06_clustering.R
# Objetivo: Clustering jer√°rquico/k-means en matriz_binaria/log2FC para patrones up/down.

# Cargar paquetes
#library(factoextra) # Para fviz_nbclust (optimal k), fviz_dend, etc. (instala si no)
#library(stats)      # Para hclust, kmeans (base R)

# Cargar matrices
matriz_binaria <- read_csv(here("salidas_data", "matriz_binaria.csv"), show_col_types = FALSE)
# O usa matriz_log2FC si prefieres valores continuos (comenta binaria)
# matriz_log2FC <- readRDS(here("salidas_data", "matriz_log2FC.rds"))

# Preparaci√≥n: Convertir a matrix num√©rica (rows=GeneID, cols=tablas)
# Maneja NA: Imputa 0 (asumir no up); filtra rows con >50% NA
mat_clust <- matriz_binaria %>%
  column_to_rownames(var = "GeneID") %>%  # Rows como GeneID
  mutate(across(everything(), ~ replace_na(., 0))) %>%  # Imputa NA=0 (no up)
  filter(rowSums(is.na(.)) / ncol(.) < 0.5) %>%  # Filtra rows >50% NA
  as.matrix()  # Para clustering

# Verificaci√≥n
cat("üìê Dimensiones para clustering:", nrow(mat_clust), "filas x", ncol(mat_clust), "columnas\n")
print(head(mat_clust))

# Paso 1: Clustering Jer√°rquico (hclust)
dist_mat <- dist(mat_clust, method = "euclidean")  # Distancia (euclidean para binario)
hclust_res <- hclust(dist_mat, method = "ward.D2")  # M√©todo ward para clusters compactos

# Plot dendrograma
fviz_dend(hclust_res, k = 5,  # Elige k inicial (ajusta)
          cex = 0.5, horiz = TRUE, main = "Dendrograma Jer√°rquico (k=5)") +
  theme_minimal()
ggsave(here("salidas", "dendrograma_hclust.png"))

# Extraer clusters (corta en k=5-10)
k_clusters <- 5  # Ajusta basado en dendrograma o elbow
clusters_h <- cutree(hclust_res, k = k_clusters)
# Agrega a df
df_clusters_h <- tibble(GeneID = rownames(mat_clust), cluster_h = clusters_h)

# Paso 2: K-means (alternativa no-jer√°rquica)
# Encuentra optimal k (elbow method)
fviz_nbclust(mat_clust, kmeans, method = "wss") +  # Within Sum Squares
  ggtitle("Elbow para Optimal K")
ggsave(here("salidas", "elbow_kmeans.png"))

# Aplica k-means con k elegido (e.g., del elbow ~4-6)
kmeans_res <- kmeans(mat_clust, centers = k_clusters, nstart = 25)  # nstart para estabilidad
clusters_k <- kmeans_res$cluster
df_clusters_k <- tibble(GeneID = rownames(mat_clust), cluster_k = clusters_k)

# Verificaci√≥n clusters
cat("Conteos por cluster (hclust):\n")
print(table(df_clusters_h$cluster_h))
cat("Conteos por cluster (kmeans):\n")
print(table(df_clusters_k$cluster_k))

# Plot clusters (e.g., PCA colored by cluster)
fviz_cluster(kmeans_res, data = mat_clust, geom = "point", ellipse.type = "convex") +
  ggtitle("K-means Clusters")
ggsave(here("salidas", "plot_kmeans_clusters.png"))

# Guardar outputs
saveRDS(df_clusters_h, here("salidas_data", "clusters_hclust.rds"))
saveRDS(df_clusters_k, here("salidas_data", "clusters_kmeans.rds"))
write_csv(df_clusters_h, here("salidas_data", "clusters_hclust.csv"))  # GeneID por cluster
write_csv(df_clusters_k, here("salidas_data", "clusters_kmeans.csv"))
cat("üíæ Clusters guardados en salidas_data.\n")


######################################################################################################
# scripts/07_correlations.R
# Objetivo: Correlaciones entre condiciones (e.g., tablas), identificar genes con FC invertido (RNAi vs OX).

# Cargar paquetes

#library(corrplot)   # Para heatmap correl (instala si no: install.packages("corrplot"))

# Cargar matrices y clusters
matriz_log2FC <- readRDS(here("salidas_data", "matriz_log2FC.rds"))
df_clusters_h <- read_csv(here("salidas_data", "clusters_hclust.csv"), show_col_types = FALSE)  # O kmeans

# Unir clusters a matriz para correl por grupo (opcional)
matriz_with_clusters <- matriz_log2FC %>%
  left_join(df_clusters_h, by = "GeneID")

# Paso 1: Matriz de correlaciones (Pearson entre columnas log2FC)
# Prepara num√©rica (imputa NA=0 para cor)
mat_cor <- matriz_log2FC %>%
  column_to_rownames("GeneID") %>%
  mutate(across(everything(), ~ replace_na(., 0))) %>%
  as.matrix()

cor_mat <- cor(mat_cor, method = "pearson")  # Correl entre tablas

# Plot heatmap correl
corrplot(cor_mat, method = "color", type = "upper", tl.cex = 0.8,
         title = "Heatmap Correlaciones log2FC", mar = c(0,0,1,0))
# Guarda manual o con png() si corrplot no ggsave

# Verificaci√≥n
print(cor_mat)  # Matriz num√©rica (e.g., alta cor LPi-tablas = similares)

# Paso 2: Filtrar genes con FC invertido (e.g., up RNAi, down OX)
# Define grupos RNAi/OX (todas columnas relevantes)
grupo_RNAi <- c("log2FC_dat_rna", "log2FC_dat_rna_lp", "log2FC_dat_rna_op")
grupo_OX <- c("log2FC_dat_ox", "log2FC_dat_ox_lp", "log2FC_dat_ox_op")

genes_invertidos <- matriz_log2FC %>%
  filter(if_any(all_of(grupo_RNAi), ~ . > 1) &  # Up en al menos una RNAi
           if_any(all_of(grupo_OX), ~ . < -1) &  # Down en al menos una OX
           if_any(matches(str_replace(grupo_RNAi, "log2FC", "padj")), ~ . < 0.05) &  # Sig
           if_any(matches(str_replace(grupo_OX, "log2FC", "padj")), ~ . < 0.05)) %>%
  pull(GeneID)

# Verificaci√≥n
cat("Genes con FC invertido (RNAi up, OX down):", length(genes_invertidos), "\n")
print(head(genes_invertidos))  # Lista IDs

# Opcional: Correl por cluster (e.g., en cluster 2)
for (clust in unique(df_clusters_h$cluster_h)) {
  mat_clust <- mat_cor[df_clusters_h$GeneID[df_clusters_h$cluster_h == clust], ]
  cor_clust <- cor(mat_clust)
  cat("Correl en cluster", clust, ":\n")
  print(cor_clust)
}

# Guardar outputs
saveRDS(list(genes_invertidos = genes_invertidos), here("salidas_data", "genes_invertidos.rds"))
write_csv(tibble(GeneID = genes_invertidos), here("salidas_data", "genes_invertidos.csv"))
saveRDS(cor_mat, here("salidas_data", "cor_matrix.rds"))
cat("üíæ Outputs guardados.\n")

###############################################
