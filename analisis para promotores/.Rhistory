# Nombres de archivo (sin extensiÃ³n)
archivos <- c(
"DE_EV",
"DE_PHR-L7-RNAi",
"DE_PHR-L7-Ox",
"DE_PHR-L7-RNAi-LPivsEVLPi",
"DE_PHR-L7Ox-LPivsEVLPi",
"DE_PHR-L7RNAi_OPivsEV_OPi",
"DE_PHR-L7Ox_OPivsEV_OPi"
)
# Leer todos los archivos y guardarlos en una lista
datos_list <- lapply(archivos, function(nombre) {
read_excel(paste0("datos/", nombre, ".xlsx"))
})
# Crear nombres de objetos mÃ¡s cortos y seguros
nombres_limpios <- c(
"ev",
"rna",
"ox",
"rna_lp",
"ox_lp",
"rna_op",
"ox_op"
)
# Asignar nombres a la lista
names(datos_list) <- nombres_limpios
datos_list$ev       # DE_EV.xlsx
datos_list$rna      # DE_PHR-L7-RNAi.xlsx
datos_list$ox_lp    # DE_PHR-L7Ox-LPivsEVLPi.xlsx
datos_list$ev       # DE_EV.xlsx
datos_list$rna      # DE_PHR-L7-RNAi.xlsx
datos_list$ox
datos_list$rna_lp
datos_list$ox_lp    # DE_PHR-L7Ox-LPivsEVLPi.xlsx
datos_list$rna_op
datos_list$ox_op
for (i in seq_along(nombres_limpios)) {
assign(paste0("dat_", nombres_limpios[i]), datos_list[[i]])
}
data.frame(objeto = paste0("dat_", nombres_limpios), archivo = archivos)
View(dat_ev)
View(dat_ev)
summary(dat_ev)
names(datos_list)
names(data.frame)
head_while(dat_ev)
head(dat_ev)
source("instalar_paquetes.R")  # Ajusta la ruta si estÃ¡ en una subcarpeta
instalar_y_cargar(
paquetes_cran = c("fs", "here", "tidyverse", "data.table", "pheatmap", "writexl", "readxl", "skimr"),
paquetes_bioc = c()
)
# Vector con nombres de tus objetos
objetos <- c("dat_ev", "dat_rna", "dat_ox", "dat_rna_lp", "dat_ox_lp", "dat_rna_op", "dat_ox_op")
# Recorrer cada objeto y mostrar informaciÃ³n clave
for (obj in objetos) {
cat("\nğŸ” Explorando:", obj, "\n")
# Obtener el objeto
tabla <- get(obj)
# Mostrar dimensiones
cat("ğŸ“ Dimensiones:", dim(tabla)[1], "filas x", dim(tabla)[2], "columnas\n")
# Mostrar nombres de columnas
cat("ğŸ§¬ Columnas:", paste(names(tabla), collapse = ", "), "\n")
# Mostrar tipos de datos
cat("ğŸ”¤ Estructura:\n")
str(tabla)
# Mostrar primeras filas
cat("ğŸ‘€ Primeras filas:\n")
print(head(tabla))
# Mostrar resumen estadÃ­stico
cat("ğŸ“Š Resumen:\n")
print(summary(tabla))
# Mostrar resumen extendido si skimr estÃ¡ disponible
if ("skimr" %in% rownames(installed.packages())) {
cat("ğŸ“‹ Resumen extendido con skimr:\n")
print(skimr::skim(tabla))
}
# Abrir en pestaÃ±a si estÃ¡s en RStudio
if (interactive()) {
View(tabla)
}
}
source("instalar_paquetes.R")  # Ajusta la ruta si estÃ¡ en una subcarpeta
instalar_y_cargar(
paquetes_cran = c("fs", "here", "tidyverse", "data.table", "pheatmap", "writexl", "readxl", "skimr"),
paquetes_bioc = c()
)
# Cargar la lista de tablas limpias desde RDS (eficiente)
tablas_limpias <- readRDS(here("salidas_data", "tablas_limpias.rds"))
print(names(tablas_limpias))
# Muestra los nombres de las columnas de la primera tabla
print(names(tablas_limpias$dat_ev))
print(names(tablas_limpias$dat_rna))
print(names(tablas_limpias$dat_ox))
print(names(tablas_limpias$dat_rna_lp))
print(names(tablas_limpias$dat_ox_lp))
print(names(tablas_limpias$dat_rna_op))
print(names(tablas_limpias$dat_ox_op))
# TambiÃ©n puedes ver las primeras filas para tener mÃ¡s contexto
print(head(tablas_limpias$dat_ev))
print(head(tablas_limpias$dat_rna))
print(head(tablas_limpias$dat_ox))
print(head(tablas_limpias$dat_rna_lp))
print(head(tablas_limpias$dat_ox_lp))
print(head(tablas_limpias$dat_rna_op))
print(head(tablas_limpias$dat_ox_op))
# Paso a: Renombrar columnas para evitar conflictos en merge (agrega sufijo por origen)
# e.g., log2FC -> log2FC_ev, padj -> padj_ev (directo, sin rename previo)
tablas_renombradas <- imap(tablas_limpias, ~ .x %>%
rename_with(~ paste0(., "_", .y), c("log2FC", "padj")) %>%  # Sufijo en columnas existentes
select(GeneID, starts_with("log2FC_"), starts_with("padj_"))  # Drop tabla_origen si no necesitas
)
install.packages("tidyverse")
source("instalar_paquetes.R")  # Ajusta la ruta si estÃ¡ en una subcarpeta
instalar_y_cargar(
paquetes_cran = c("fs", "here", "tidyverse", "data.table", "pheatmap", "writexl", "readxl", "skimr"),
paquetes_bioc = c()
)
# Cargar la lista de tablas limpias desde RDS (eficiente)
tablas_limpias <- readRDS(here("salidas_data", "tablas_limpias.rds"))
print(names(tablas_limpias))
# Muestra los nombres de las columnas de la primera tabla
print(names(tablas_limpias$dat_ev))
print(names(tablas_limpias$dat_rna))
print(names(tablas_limpias$dat_ox))
print(names(tablas_limpias$dat_rna_lp))
print(names(tablas_limpias$dat_ox_lp))
print(names(tablas_limpias$dat_rna_op))
print(names(tablas_limpias$dat_ox_op))
# TambiÃ©n puedes ver las primeras filas para tener mÃ¡s contexto
print(head(tablas_limpias$dat_ev))
print(head(tablas_limpias$dat_rna))
print(head(tablas_limpias$dat_ox))
print(head(tablas_limpias$dat_rna_lp))
print(head(tablas_limpias$dat_ox_lp))
print(head(tablas_limpias$dat_rna_op))
print(head(tablas_limpias$dat_ox_op))
# Paso a: Renombrar columnas para evitar conflictos en merge (agrega sufijo por origen)
# e.g., log2FC -> log2FC_ev, padj -> padj_ev (directo, sin rename previo)
tablas_renombradas <- imap(tablas_limpias, ~ .x %>%
rename_with(~ paste0(., "_", .y), c("log2FC", "padj")) %>%  # Sufijo en columnas existentes
select(GeneID, starts_with("log2FC_"), starts_with("padj_"))  # Drop tabla_origen si no necesitas
)
tablas_renombradas <- imap(tablas_limpias, ~ .x %>%
dplyr::rename_with(~ paste0(., "_", .y), c("log2FC", "padj")) %>%  # Sufijo en columnas existentes
dplyr::select(GeneID, starts_with("log2FC_"), starts_with("padj_"))  # Drop tabla_origen si no necesitas
)
# Cargar la lista de tablas limpias desde RDS (eficiente)
tablas_limpias <- readRDS(here("salidas_data", "tablas_limpias.rds"))
print(names(tablas_limpias))
# Muestra los nombres de las columnas de la primera tabla
print(names(tablas_limpias$dat_ev))
print(names(tablas_limpias$dat_rna))
print(names(tablas_limpias$dat_ox))
print(names(tablas_limpias$dat_rna_lp))
print(names(tablas_limpias$dat_ox_lp))
print(names(tablas_limpias$dat_rna_op))
print(names(tablas_limpias$dat_ox_op))
# TambiÃ©n puedes ver las primeras filas para tener mÃ¡s contexto
print(head(tablas_limpias$dat_ev))
print(head(tablas_limpias$dat_rna))
print(head(tablas_limpias$dat_ox))
print(head(tablas_limpias$dat_rna_lp))
print(head(tablas_limpias$dat_ox_lp))
print(head(tablas_limpias$dat_rna_op))
print(head(tablas_limpias$dat_ox_op))
# Paso a: Renombrar columnas para evitar conflictos en merge (agrega sufijo por origen)
# e.g., log2FC -> log2FC_ev, padj -> padj_ev (directo, sin rename previo)
tablas_renombradas <- imap(tablas_limpias, ~ .x %>%
dplyr::rename_with(~ paste0(., "_", .y), c("log2FC", "padj")) %>%  # Sufijo en columnas existentes
dplyr::select(GeneID, starts_with("log2FC_"), starts_with("padj_"))  # Drop tabla_origen si no necesitas
)
# Alternativa usando map2, que es mÃ¡s explÃ­cito
tablas_renombradas <- map2(
tablas_limpias,          # Argumento 1: la lista de tablas
names(tablas_limpias),   # Argumento 2: el vector de nombres
# La funciÃ³n es la misma, pero ahora .x es un elemento del primer argumento
# y .y es un elemento del segundo argumento
~ .x %>%
rename_with(~ paste0(., "_", .y), c("log2FC", "padj")) %>%
select(GeneID, starts_with("log2FC_"), starts_with("padj_"))
)
# Paso a: Renombrar columnas (versiÃ³n con bucle for a prueba de errores)
# 1. Crear una lista vacÃ­a para guardar los resultados
tablas_renombradas <- list()
# 2. Iterar sobre los NOMBRES de la lista original
for (nombre_tabla in names(tablas_limpias)) {
cat("Procesando tabla:", nombre_tabla, "\n") # Mensaje para ver el progreso
# 3. Obtener la tabla actual
tabla_actual <- tablas_limpias[[nombre_tabla]]
# 4. Renombrar y seleccionar columnas en esta tabla
tabla_procesada <- tabla_actual %>%
rename_with(~ paste0(., "_", nombre_tabla), c("log2FC", "padj")) %>%
select(GeneID, starts_with("log2FC_"), starts_with("padj_"))
# 5. Guardar la tabla procesada en la nueva lista
tablas_renombradas[[nombre_tabla]] <- tabla_procesada
}
# El resto de tu script continÃºa exactamente igual...
df_unificado <- reduce(tablas_renombradas, full_join, by = "GeneID")
# Paso b: Merge secuencial con reduce y full_join por GeneID
df_unificado <- reduce(tablas_renombradas, full_join, by = "GeneID")
# Paso c: Manejar duplicados GeneID (si hay, aunque raro)
# Chequea y resume (e.g., media de log2FC si duplicado)
duplicados <- df_unificado %>%
group_by(GeneID) %>%
filter(n() > 1)
if (nrow(duplicados) > 0) {
cat("âš ï¸ Duplicados encontrados:", nrow(duplicados), "- Resumiendo con media.\n")
df_unificado <- df_unificado %>%
group_by(GeneID) %>%
summarise(across(everything(), ~ mean(.x, na.rm = TRUE)))  # Media para num, o ajusta
} else {
cat("âœ… No duplicados en GeneID.\n")
}
# VerificaciÃ³n post-merge
cat("ğŸ“ Dimensiones unificado:", nrow(df_unificado), "filas x", ncol(df_unificado), "columnas\n")
cat("ğŸ§¬ Columnas:", paste(names(df_unificado), collapse = ", "), "\n")
cat("ğŸ‘€ Primeras filas:\n")
print(head(df_unificado))
cat("ğŸ“Š Resumen:\n")
print(summary(df_unificado))
# Opcional: skim(df_unificado) si skimr cargado
if ("skimr" %in% rownames(installed.packages())) {
print(skimr::skim(df_unificado))
}
# Abrir en View para inspecciÃ³n
if (interactive()) {
View(df_unificado)
}
# Paso d: Guardar unificado
saveRDS(df_unificado, here("salidas_data", "df_unificado.rds"))
write_csv(df_unificado, here("salidas_data", "df_unificado.csv"))  # Opcional CSV para backup
cat("ğŸ’¾ Guardado en salidas_data/df_unificado.rds y .csv\n")
sessionInfo()
#DiseÃ±o del Script para Crear la Matriz log2FC por GeneID/Tabla
# scripts/04_create_matrices.R
# Objetivo: Crear matriz log2FC (y opcional padj) por GeneID/tabla a partir de df_unificado.
# Cargar paquetes
library(tidyverse)  # Para select, mutate, etc.
library(here)       # Para paths
# Cargar df_unificado desde RDS
df_unificado <- readRDS(here("salidas_data", "df_unificado.rds"))
# Paso 1: Crear matriz log2FC
# Selecciona GeneID + todas columnas que empiezan con "log2FC_"
matriz_log2FC <- df_unificado %>%
select(GeneID, starts_with("log2FC_")) %>%  # Matriz: rows=GeneID, cols=tablas
# Opcional: Manejar NA (e.g., imputar 0 para no-DEGs, pero cuidadoâ€”puede bias; deja NA para ahora)
# mutate(across(starts_with("log2FC_"), ~ replace_na(., 0))) %>%
arrange(GeneID)  # Ordena por GeneID para consistencia
# VerificaciÃ³n
cat("ğŸ“ Dimensiones matriz_log2FC:", nrow(matriz_log2FC), "filas x", ncol(matriz_log2FC), "columnas\n")
cat("ğŸ§¬ Columnas:", paste(names(matriz_log2FC), collapse = ", "), "\n")
cat("ğŸ‘€ Primeras filas:\n")
print(head(matriz_log2FC))
cat("ğŸ“Š Resumen:\n")
print(summary(matriz_log2FC))
# Opcional skim
if ("skimr" %in% rownames(installed.packages())) {
print(skimr::skim(matriz_log2FC))
}
# Abrir en View
if (interactive()) {
View(matriz_log2FC)
}
# Opcional: Crear matriz padj similar (para filtrar overlaps por significancia)
matriz_padj <- df_unificado %>%
select(GeneID, starts_with("padj_")) %>%
# mutate(across(starts_with("padj_"), ~ replace_na(., 1))) %>%  # NA=1 (no sig) si quieres
arrange(GeneID)
# VerificaciÃ³n similar para padj (repite si usas)
cat("ğŸ“ Dimensiones matriz_padj:", nrow(matriz_padj), "filas x", ncol(matriz_padj), "columnas\n")
# ... (agrega head/summary/skim similar)
# Guardar matrices
saveRDS(matriz_log2FC, here("salidas_data", "matriz_log2FC.rds"))
write_csv(matriz_log2FC, here("salidas_data", "matriz_log2FC.csv"))
saveRDS(matriz_padj, here("salidas_data", "matriz_padj.rds"))  # Opcional
write_csv(matriz_padj, here("salidas_data", "matriz_padj.csv"))  # Opcional
cat("ğŸ’¾ Matrices guardadas en salidas_data.\n")
source("instalar_paquetes.R")  # Ajusta la ruta si estÃ¡ en una subcarpeta
instalar_y_cargar(
paquetes_cran = c("fs", "here", "tidyverse", "data.table", "pheatmap", "writexl", "readxl", "skimr", "ggvenn"),
paquetes_bioc = c()
)
# scripts/05_venn_overlaps.R
# Objetivo: Filtrar genes up, crear listas por grupo (LPi vs OPi), calcular overlaps/Venn.
# Cargar matrices desde RDS
matriz_log2FC <- readRDS(here("salidas_data", "matriz_log2FC.rds"))
matriz_padj <- readRDS(here("salidas_data", "matriz_padj.rds"))
# Definir thresholds para "up" genes (ajusta segÃºn necesidad, e.g., log2FC >1 = 2x up, padj <0.05)
fc_threshold <- 1    # log2FC >1
padj_threshold <- 0.05
# Definir grupos de tablas (basado en LPi vs OPi focus)
grupo_LPi <- c("log2FC_dat_ev", "log2FC_dat_rna_lp", "log2FC_dat_ox_lp")  # LPi-related
grupo_OPi <- c("log2FC_dat_rna_op", "log2FC_dat_ox_op")                   # OPi-related
# Opcional: Agrega mÃ¡s grupos, e.g., RNAi: "log2FC_dat_rna", "log2FC_dat_rna_lp", "log2FC_dat_rna_op"
# FunciÃ³n para filtrar genes up en un grupo de columnas
get_up_genes <- function(mat_fc, mat_padj, grupo_cols) {
mat_fc %>%
filter(if_all(all_of(grupo_cols), ~ . > fc_threshold) &  # Up en TODAS columnas del grupo (stricter; usa if_any para ANY)
if_all(matches(str_replace(grupo_cols, "log2FC", "padj")), ~ . < padj_threshold)) %>%  # Sig en padj correspondientes
pull(GeneID) %>%  # Extrae lista de GeneID
unique()          # Evita dups
}
# Crear listas de genes up por grupo
genes_up_LPi <- get_up_genes(matriz_log2FC, matriz_padj, grupo_LPi)
genes_up_OPi <- get_up_genes(matriz_log2FC, matriz_padj, grupo_OPi)
# VerificaciÃ³n: Conteos iniciales
cat("Genes up en LPi grupo:", length(genes_up_LPi), "\n")
cat("Genes up en OPi grupo:", length(genes_up_OPi), "\n")
# Paso para overlaps/counts (simple intersecciÃ³n)
overlap_LPi_OPi <- intersect(genes_up_LPi, genes_up_OPi)  # Compartidos
unique_LPi <- setdiff(genes_up_LPi, genes_up_OPi)         # Ãšnicos LPi
unique_OPi <- setdiff(genes_up_OPi, genes_up_LPi)         # Ãšnicos OPi
cat("Overlap (compartidos):", length(overlap_LPi_OPi), "\n")
cat("Ãšnicos LPi:", length(unique_LPi), "\n")
cat("Ãšnicos OPi:", length(unique_OPi), "\n")
# Crear matriz binaria de presencia (1=up en tabla, 0=no) para anÃ¡lisis avanzado
# Usa matriz_log2FC como base, binariza basado en thresholds
matriz_binaria <- matriz_log2FC %>%
mutate(across(starts_with("log2FC_"),
~ ifelse(. > fc_threshold &
matriz_padj[[str_replace(cur_column(), "log2FC", "padj")]] < padj_threshold, 1, 0)))
# VerificaciÃ³n matriz binaria
cat("ğŸ“ Dimensiones matriz_binaria:", nrow(matriz_binaria), "filas x", ncol(matriz_binaria), "columnas\n")
print(head(matriz_binaria))
print(summary(matriz_binaria))  # DeberÃ­a mostrar 0/1/NA
# Venn plot simple (para 2 grupos; extiende a mÃ¡s con list)
venn_list <- list(LPi = genes_up_LPi, OPi = genes_up_OPi)
ggvenn(venn_list, fill_color = c("blue", "green"), show_percentage = TRUE) +
ggtitle("Venn: Up genes LPi vs OPi")
ggsave(here("salidas", "venn_LPi_vs_OPi.png"))  # Guarda plot
# Guardar outputs
saveRDS(venn_list, here("salidas_data", "venn_lists.rds"))  # Listas para reuse
write_csv(matriz_binaria, here("salidas_data", "matriz_binaria.csv"))  # Matriz para anÃ¡lisis
cat("ğŸ’¾ Outputs guardados en salidas_data y salidas.\n")
# scripts/05_venn_overlaps.R
# Objetivo: Filtrar genes up, crear listas por grupo (LPi vs OPi), calcular overlaps/Venn.
# Cargar matrices desde RDS
matriz_log2FC <- readRDS(here("salidas_data", "matriz_log2FC.rds"))
matriz_padj <- readRDS(here("salidas_data", "matriz_padj.rds"))
# Definir thresholds para "up" genes (ajusta segÃºn necesidad, e.g., log2FC >1 = 2x up, padj <0.05)
fc_threshold <- 0.5    # log2FC >1
padj_threshold <- 0.05
# Definir grupos de tablas (basado en LPi vs OPi focus)
grupo_LPi <- c("log2FC_dat_ev", "log2FC_dat_rna_lp", "log2FC_dat_ox_lp")  # LPi-related
grupo_OPi <- c("log2FC_dat_rna_op", "log2FC_dat_ox_op")                   # OPi-related
# Opcional: Agrega mÃ¡s grupos, e.g., RNAi: "log2FC_dat_rna", "log2FC_dat_rna_lp", "log2FC_dat_rna_op"
# FunciÃ³n para filtrar genes up en un grupo de columnas
get_up_genes <- function(mat_fc, mat_padj, grupo_cols) {
mat_fc %>%
filter(if_any(all_of(grupo_cols), ~ . > fc_threshold) &  # Up en TODAS columnas del grupo (stricter; usa if_any para ANY)
if_any(matches(str_replace(grupo_cols, "log2FC", "padj")), ~ . < padj_threshold)) %>%  # Sig en padj correspondientes
pull(GeneID) %>%  # Extrae lista de GeneID
unique()          # Evita dups
}
# Crear listas de genes up por grupo
genes_up_LPi <- get_up_genes(matriz_log2FC, matriz_padj, grupo_LPi)
genes_up_OPi <- get_up_genes(matriz_log2FC, matriz_padj, grupo_OPi)
# VerificaciÃ³n: Conteos iniciales
cat("Genes up en LPi grupo:", length(genes_up_LPi), "\n")
cat("Genes up en OPi grupo:", length(genes_up_OPi), "\n")
# Paso para overlaps/counts (simple intersecciÃ³n)
overlap_LPi_OPi <- intersect(genes_up_LPi, genes_up_OPi)  # Compartidos
unique_LPi <- setdiff(genes_up_LPi, genes_up_OPi)         # Ãšnicos LPi
unique_OPi <- setdiff(genes_up_OPi, genes_up_LPi)         # Ãšnicos OPi
cat("Overlap (compartidos):", length(overlap_LPi_OPi), "\n")
cat("Ãšnicos LPi:", length(unique_LPi), "\n")
cat("Ãšnicos OPi:", length(unique_OPi), "\n")
# Crear matriz binaria de presencia (1=up en tabla, 0=no) para anÃ¡lisis avanzado
# Usa matriz_log2FC como base, binariza basado en thresholds
matriz_binaria <- matriz_log2FC %>%
mutate(across(starts_with("log2FC_"),
~ ifelse(. > fc_threshold &
matriz_padj[[str_replace(cur_column(), "log2FC", "padj")]] < padj_threshold, 1, 0)))
# VerificaciÃ³n matriz binaria
cat("ğŸ“ Dimensiones matriz_binaria:", nrow(matriz_binaria), "filas x", ncol(matriz_binaria), "columnas\n")
print(head(matriz_binaria))
print(summary(matriz_binaria))  # DeberÃ­a mostrar 0/1/NA
# Venn plot simple (para 2 grupos; extiende a mÃ¡s con list)
venn_list <- list(LPi = genes_up_LPi, OPi = genes_up_OPi)
ggvenn(venn_list, fill_color = c("blue", "green"), show_percentage = TRUE) +
ggtitle("Venn: Up genes LPi vs OPi")
ggsave(here("salidas", "venn_LPi_vs_OPi.png"))  # Guarda plot
# Guardar outputs
saveRDS(venn_list, here("salidas_data", "venn_lists.rds"))  # Listas para reuse
write_csv(matriz_binaria, here("salidas_data", "matriz_binaria.csv"))  # Matriz para anÃ¡lisis
cat("ğŸ’¾ Outputs guardados en salidas_data y salidas.\n")
source("instalar_paquetes.R")  # Ajusta la ruta si estÃ¡ en una subcarpeta
instalar_y_cargar(
paquetes_cran = c("fs", "here", "tidyverse", "data.table", "pheatmap", "writexl", "readxl", "skimr", "ggvenn", "factoextra"),
paquetes_bioc = c()
)
#Extraer listas de GeneID para promotores
write_csv(tibble(GeneID = unique_LPi), here("salidas_data", "candidatos_LPi_unicos_Venn.csv"))
write_csv(tibble(GeneID = overlap_LPi_OPi), here("salidas_data", "candidatos_compartidos_Venn.csv"))
write_csv(tibble(GeneID = unique_OPi), here("salidas_data", "candidatos_OPi_unicos_Venn.csv"))
source("instalar_paquetes.R")  # Ajusta la ruta si estÃ¡ en una subcarpeta
instalar_y_cargar(
paquetes_cran = c("fs", "here", "tidyverse", "data.table", "pheatmap", "writexl", "readxl", "skimr", "ggvenn", "factoextra", "stats"),
paquetes_bioc = c()
)
# scripts/06_clustering.R
# Objetivo: Clustering jerÃ¡rquico/k-means en matriz_binaria/log2FC para patrones up/down.
# Cargar paquetes
#library(factoextra) # Para fviz_nbclust (optimal k), fviz_dend, etc. (instala si no)
#library(stats)      # Para hclust, kmeans (base R)
# Cargar matrices
matriz_binaria <- read_csv(here("salidas_data", "matriz_binaria.csv"), show_col_types = FALSE)
# O usa matriz_log2FC si prefieres valores continuos (comenta binaria)
# matriz_log2FC <- readRDS(here("salidas_data", "matriz_log2FC.rds"))
# PreparaciÃ³n: Convertir a matrix numÃ©rica (rows=GeneID, cols=tablas)
# Maneja NA: Imputa 0 (asumir no up); filtra rows con >50% NA
mat_clust <- matriz_binaria %>%
column_to_rownames(var = "GeneID") %>%  # Rows como GeneID
mutate(across(everything(), ~ replace_na(., 0))) %>%  # Imputa NA=0 (no up)
filter(rowSums(is.na(.)) / ncol(.) < 0.5) %>%  # Filtra rows >50% NA
as.matrix()  # Para clustering
# VerificaciÃ³n
cat("ğŸ“ Dimensiones para clustering:", nrow(mat_clust), "filas x", ncol(mat_clust), "columnas\n")
print(head(mat_clust))
# Paso 1: Clustering JerÃ¡rquico (hclust)
dist_mat <- dist(mat_clust, method = "euclidean")  # Distancia (euclidean para binario)
hclust_res <- hclust(dist_mat, method = "ward.D2")  # MÃ©todo ward para clusters compactos
# Plot dendrograma
fviz_dend(hclust_res, k = 5,  # Elige k inicial (ajusta)
cex = 0.5, horiz = TRUE, main = "Dendrograma JerÃ¡rquico (k=5)") +
theme_minimal()
ggsave(here("salidas", "dendrograma_hclust.png"))
# Extraer clusters (corta en k=5-10)
k_clusters <- 5  # Ajusta basado en dendrograma o elbow
clusters_h <- cutree(hclust_res, k = k_clusters)
# Agrega a df
df_clusters_h <- tibble(GeneID = rownames(mat_clust), cluster_h = clusters_h)
# Paso 2: K-means (alternativa no-jerÃ¡rquica)
# Encuentra optimal k (elbow method)
fviz_nbclust(mat_clust, kmeans, method = "wss") +  # Within Sum Squares
ggtitle("Elbow para Optimal K")
ggsave(here("salidas", "elbow_kmeans.png"))
# Aplica k-means con k elegido (e.g., del elbow ~4-6)
kmeans_res <- kmeans(mat_clust, centers = k_clusters, nstart = 25)  # nstart para estabilidad
clusters_k <- kmeans_res$cluster
df_clusters_k <- tibble(GeneID = rownames(mat_clust), cluster_k = clusters_k)
# VerificaciÃ³n clusters
cat("Conteos por cluster (hclust):\n")
print(table(df_clusters_h$cluster_h))
cat("Conteos por cluster (kmeans):\n")
print(table(df_clusters_k$cluster_k))
# Plot clusters (e.g., PCA colored by cluster)
fviz_cluster(kmeans_res, data = mat_clust, geom = "point", ellipse.type = "convex") +
ggtitle("K-means Clusters")
ggsave(here("salidas", "plot_kmeans_clusters.png"))
# Guardar outputs
saveRDS(df_clusters_h, here("salidas_data", "clusters_hclust.rds"))
saveRDS(df_clusters_k, here("salidas_data", "clusters_kmeans.rds"))
write_csv(df_clusters_h, here("salidas_data", "clusters_hclust.csv"))  # GeneID por cluster
write_csv(df_clusters_k, here("salidas_data", "clusters_kmeans.csv"))
cat("ğŸ’¾ Clusters guardados en salidas_data.\n")
source("instalar_paquetes.R")  # Ajusta la ruta si estÃ¡ en una subcarpeta
instalar_y_cargar(
paquetes_cran = c("fs", "here", "tidyverse", "data.table", "pheatmap", "writexl", "readxl", "skimr", "ggvenn", "factoextra", "stats","corrplot"),
paquetes_bioc = c()
)
# Cargar matrices y clusters
matriz_log2FC <- readRDS(here("salidas_data", "matriz_log2FC.rds"))
df_clusters_h <- read_csv(here("salidas_data", "clusters_hclust.csv"), show_col_types = FALSE)  # O kmeans
# Unir clusters a matriz para correl por grupo (opcional)
matriz_with_clusters <- matriz_log2FC %>%
left_join(df_clusters_h, by = "GeneID")
# Paso 1: Matriz de correlaciones (Pearson entre columnas log2FC)
# Prepara numÃ©rica (imputa NA=0 para cor)
mat_cor <- matriz_log2FC %>%
column_to_rownames("GeneID") %>%
mutate(across(everything(), ~ replace_na(., 0))) %>%
as.matrix()
cor_mat <- cor(mat_cor, method = "pearson")  # Correl entre tablas
# Plot heatmap correl
corrplot(cor_mat, method = "color", type = "upper", tl.cex = 0.8,
title = "Heatmap Correlaciones log2FC", mar = c(0,0,1,0))
# Guarda manual o con png() si corrplot no ggsave
# VerificaciÃ³n
print(cor_mat)  # Matriz numÃ©rica (e.g., alta cor LPi-tablas = similares)
# Paso 2: Filtrar genes con FC invertido (e.g., up RNAi, down OX)
# Define grupos RNAi/OX (todas columnas relevantes)
grupo_RNAi <- c("log2FC_dat_rna", "log2FC_dat_rna_lp", "log2FC_dat_rna_op")
grupo_OX <- c("log2FC_dat_ox", "log2FC_dat_ox_lp", "log2FC_dat_ox_op")
genes_invertidos <- matriz_log2FC %>%
filter(if_any(all_of(grupo_RNAi), ~ . > 1) &  # Up en al menos una RNAi
if_any(all_of(grupo_OX), ~ . < -1) &  # Down en al menos una OX
if_any(matches(str_replace(grupo_RNAi, "log2FC", "padj")), ~ . < 0.05) &  # Sig
if_any(matches(str_replace(grupo_OX, "log2FC", "padj")), ~ . < 0.05)) %>%
pull(GeneID)
# VerificaciÃ³n
cat("Genes con FC invertido (RNAi up, OX down):", length(genes_invertidos), "\n")
print(head(genes_invertidos))  # Lista IDs
# Opcional: Correl por cluster (e.g., en cluster 2)
for (clust in unique(df_clusters_h$cluster_h)) {
mat_clust <- mat_cor[df_clusters_h$GeneID[df_clusters_h$cluster_h == clust], ]
cor_clust <- cor(mat_clust)
cat("Correl en cluster", clust, ":\n")
print(cor_clust)
}
# Guardar outputs
saveRDS(list(genes_invertidos = genes_invertidos), here("salidas_data", "genes_invertidos.rds"))
write_csv(tibble(GeneID = genes_invertidos), here("salidas_data", "genes_invertidos.csv"))
saveRDS(cor_mat, here("salidas_data", "cor_matrix.rds"))
cat("ğŸ’¾ Outputs guardados.\n")
source("instalar_paquetes.R")  # Ajusta la ruta si estÃ¡ en una subcarpeta
instalar_y_cargar(
paquetes_cran = c("fs", "here", "tidyverse", "data.table", "pheatmap", "writexl", "readxl", "skimr", "ggvenn", "factoextra", "stats","corrplot"),
paquetes_bioc = c("biomartr")
)
load("F:/analisis_R_promotores/Promotor/analisis para promotores/.RData")
